type: install
version: 1.5
id: kubernetes
baseUrl: https://raw.githubusercontent.com/jelastic-jps/kubernetes/v1.16.8
description:
  text: /text/description-kube.md
  short: Kubernetes cluster with automated scaling & cost efficient pay-per-use pricing for running cloud-native microservices.
categories:
  - apps/clusters
  - apps/dev-and-admin-tools

logo: /images/k8s-logo.png
name: Kubernetes Cluster
targetRegions:
  type: vz7

ssl: true
onBeforeInit: /scripts/beforeinit.js
onBeforeInstall: /scripts/beforeinstall.js

nodes: definedInOnBeforeInstall

skipNodeEmails: true

globals:
    dashboardUrl:  https://${env.domain}/kubernetes-dashboard/

onInstall:
  - block-masters-scaling
  - prepare-instances
  - init-main-master
  - init-slave-masters
  - connect-workers: cp
  - setup-overlay
  - if ('${settings.ingress-controller}' == 'Nginx'):
      - setGlobals:
          ingress-dir: nginx
      - install-nginx
  - elif ('${settings.ingress-controller}' == 'HAProxy'):
      - setGlobals:
          ingress-dir: haproxy
      - install-haproxy
  - else:
      - setGlobals:
          ingress-dir: traefik
      - install-traefik
  - configure-remote-api
  - install-components
  - install-helm-master
  - if ('${globals.k8sm-slave-ids}'):
      install-helm-slave: ${globals.k8sm-slave-ids}
  - generate-admin-token
  - helm-components
  - deploy

  - if (${settings.api:true}):
      - setup-remote-api: true

  - if (${settings.monitoring:false}):
        - install-monitoring

  - if (${settings.jaeger:false}):
        - install-jaeger

  - if ('${env.protocol}' == 'http'):
      - api: env.control.AddEndpoint
        nodeId: ${nodes.cp.master.id}
        privatePort: 30777
        protocol: TCP
        name: Dashboard Self-Signed HTTPS
      - setGlobals:
          dashboardUrl: https://node${nodes.cp.master.id}-${env.domain}:${response.object.publicPort}/

  - setGlobals:
        default_success: |
             Enter [Kubernetes dashboard](${globals.dashboardUrl}) ${globals.default_api:} using the Access Token:

             ```${globals.token}```
             Press **Open in Browser** to view a default web page of your application.
             To bind a custom domain name with your Kubernetes cluster please refer to the steps described in Jelastic [documentation](https://docs.jelastic.com/custom-domains).
  - check-health

onAfterScaleOut[cp]:
  - cmd[${nodes.k8sm.master.id}]: |-
      token_age=$(expr $(date +%s) - $(stat /var/log/kubeadm-init.log -c %Y))
      [ ${token_age} -lt $((20*60*60)) ] && { sed -n '/kubeadm join/,/^$/{/./p}' /var/log/kubeadm-init.log | sed ':a;N;$!ba;s/\\\n//g' | grep -v 'control-plane'; } || { kubeadm token create --print-join-command; }
  - setGlobals:
      worker_join_cmd: ${response.out}
  - set:
      nodes: ${event.response.nodes.join(id,)}
  - cmd [${this.nodes}]: init-instance.sh --type=worker --base-url=$(echo '${baseUrl}' | base64 -w 0)
  - connect-workers: ${this.nodes}

onBeforeScaleIn[cp]:
  forEach(event.response.nodes):
    removeWorker:
      workerHostname: node${@i.id}-${env.domain}

onBeforeClone:
  stopEvent:
    type: warning
    message: Kubernetes Cluster cloning is not supported yet!

onBeforeRedeployContainer:
  if (!${event.params.skipReinstall:false}):
    stopEvent:
      type: warning
      message: Kubernetes Cluster redeploy is not supported. Please use 'Cluster Upgrade' add-on if you need to upgrade cluster version.

onAfterSetExtIpCount[cp]:
  - log: 'attached ips: ${event.response.attachedIps.join(,)}, detached ips: ${event.response.detachedIps.join(,)}'
  - cmd[${nodes.k8sm.master.id}]: metallb-config -a '${event.response.attachedIps.join(,)}' -d '${event.response.detachedIps.join(,)}'
  - cmd[cp]: systemctl restart kube-config.service

actions:
  block-masters-scaling:
    env.control.ApplyNodeGroupData[k8sm]:
      data:
        validation:
          minCount: ${nodes.k8sm.length}
          maxCount: ${nodes.k8sm.length}

  prepare-instances:
    execCmd:
      - nodeGroup: k8sm
        commands: init-instance.sh --type=master --base-url=$(echo '${baseUrl}' | base64 -w 0)
      - nodeGroup: cp
        commands: init-instance.sh --type=worker --base-url=$(echo '${baseUrl}' | base64 -w 0)
    user: root
    sync: false

  init-main-master:
    - if (${nodes.mbl.length:0}):
        cmd[mbl]: |-
          sed -i '/^<\/mappings>.*/i \\t<pair frontend_port="6443" backend_port="6443" description="CPlane balancing" option="tcp-check" params="check fall 3 rise 2">' /etc/haproxy/tcpmaps/mappings.xml
          sed -i 's/^bind :::80/#bind :::80/g' /etc/haproxy/haproxy.cfg
          sed -i '/^daemon$/a stats socket /var/run/haproxy.sock mode 660 level admin' /etc/haproxy/haproxy.cfg
          sed -i '/^daemon$/a stats timeout 2m' /etc/haproxy/haproxy.cfg
          echo '${nodes.k8sm.master.intIP}' > /etc/haproxy/hosts
          jem balancer rebuildCommon
        user: root
    - cmd[${nodes.k8sm.master.id}]: |-
        systemctl daemon-reload > /dev/null 2>&1
        entryPoint=$((( ${nodes.mbl.length:0} > 0 )) && echo mbl || echo k8sm)
        sed -i "s/^controlPlaneEndpoint:.*/controlPlaneEndpoint: \"${entryPoint}.${env.domain}:6443\"/g" /etc/kubernetes/custom-kubeadm.yaml
        while true; do [ -f "/tmp/jelastic-init-mark" ] && break; echo "Waiting for cluster initial configuration"; sleep 3; done
        kubeadm init --config /etc/kubernetes/custom-kubeadm.yaml --upload-certs --ignore-preflight-errors=swap,numcpu | tee /var/log/kubeadm-init.log
    - configure-master: ${nodes.k8sm.master.id}
    - cmd[${nodes.k8sm.master.id}]: sed -n '/kubeadm join/,/^$/{/./p}' /var/log/kubeadm-init.log | sed ':a;N;$!ba;s/\\\n//g' | grep 'control-plane'
    - setGlobals:
        master_join_cmd: ${response.out}
    - cmd[${nodes.k8sm.master.id}]: sed -n '/kubeadm join/,/^$/{/./p}' /var/log/kubeadm-init.log | sed ':a;N;$!ba;s/\\\n//g' | grep -v 'control-plane'
    - setGlobals:
        worker_join_cmd: ${response.out}
    - if (${settings.api:true}):
        - setGlobals:
            default_api: or [Remote API Endpoint](${env.protocol}://${env.domain}/api/)

  init-slave-masters:
    - script: |
        return {
          result : 0,
          nodes: '${nodes.k8sm.join(id,)}'.replace(/\b${nodes.k8sm.master.id},?\b/, '').replace(/,$/, '').split(','),
          ips: '${nodes.k8sm.join(intIP,)}'.replace(/\b${nodes.k8sm.master.intIP},?\b/, '').replace(/,/g, ' ')
        };
    - setGlobals:
        k8sm-slave-ids: ${response.nodes.join(,)}
        k8sm-slave-ips: ${response.ips}
    - if ('${globals.k8sm-slave-ids}'):
      - forEach(node:response.nodes):
          - cmd[${@node}]: |-
              sleep 5
              while true; do [ -f "/tmp/jelastic-init-mark" ] && break; echo "Waiting for cluster initial configuration"; sleep 3; done
              systemctl daemon-reload > /dev/null 2>&1
              ${globals.master_join_cmd} --ignore-preflight-errors=swap,numcpu | tee /var/log/kubeadm-join.log
      - configure-master: ${globals.k8sm-slave-ids}
      - activate-slave-masters: ${globals.k8sm-slave-ips}

  configure-master:
    cmd[${this}]: |-
      mkdir -p $HOME/.kube
      cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
      chown root:root $HOME/.kube/config
      systemctl enable kubelet.service
      /usr/local/sbin/master-postconfig.sh

  activate-slave-masters:
    - cmd[mbl]: |-
        for item in ${this}; do echo "${item}" >> /etc/haproxy/hosts; done
        jem balancer rebuildCommon
      user: root
    - cmd[${nodes.k8sm.master.id}]: |-
        for item in ${this}; do
          kubectl get node --selector='node-role.kubernetes.io/master' -o wide 2>/dev/null | grep -q "[[:space:]]${item}[[:space:]]" || {
            slave_hostname=$(kubectl get nodes -o custom-columns=NAME:.metadata.name,IP:.status.addresses[*].address --no-headers | grep "[[:space:]]${item}," | cut -f 1 -d ' ');
            [ -z "${slave_hostname}" ] || {
              kubectl label node "${slave_hostname}" node-role.kubernetes.io/master=;
              kubectl taint node "${slave_hostname}" node-role.kubernetes.io/master=:NoSchedule;
              echo "${slave_hostname} slave master processed";
            };
          }
        done

  connect-workers:
    - cmd[${this}]: |-
        while true; do [ -f "/tmp/jelastic-init-mark" ] && break; echo "Waiting for cluster initial configuration"; sleep 3; done
        local_ip=$(/usr/sbin/ip route get 1.2.3.4 | grep -v 'cache' | uniq | head -n 1 | sed -n 's/.* src \([^ ]*\).*/\1/p')
        [ -n "${local_ip}" ] || exit 1
        local_ip_route="10.244.0.0/15 dev venet0 src ${local_ip}"
        /usr/sbin/ip route add ${local_ip_route} && echo "${local_ip_route}" >> /etc/sysconfig/network-scripts/route-venet0
        sed -i "/^KUBELET_EXTRA_ARGS/ s/\"$/ --node-ip=${local_ip}\"/" /etc/sysconfig/kubelet
        systemctl daemon-reload > /dev/null 2>&1
        screen -d -m /usr/bin/bash -c '${globals.worker_join_cmd} --ignore-preflight-errors=swap,numcpu 1>/var/log/kubeadm-join.log 2>/var/log/kubeadm-join-error.log'
        systemctl enable kubelet.service

  setup-overlay:
    cmd[${nodes.k8sm.master.id}]: |-
      kubectl apply -f ${baseUrl}/addons/weave-pack.yaml

  install-nginx:
     cmd[${nodes.k8sm.master.id}]: |-
      kubectl apply -f ${baseUrl}/addons/nginx/mandatory.yaml
      kubectl apply -f ${baseUrl}/addons/nginx/cloud-generic.yaml

  install-haproxy:
     cmd[${nodes.k8sm.master.id}]: |-
      kubectl apply -f ${baseUrl}/addons/haproxy/haproxy-deployment.yaml

  install-traefik:
     cmd[${nodes.k8sm.master.id}]: |-
      kubectl apply -f ${baseUrl}/addons/traefik/traefik-rbac.yaml
      kubectl apply -f ${baseUrl}/addons/traefik/traefik-ds.yaml
      kubectl apply -f ${baseUrl}/addons/traefik/traefik-ui.yaml

  configure-remote-api:
      - if (${settings.api:true}):
          - cmd[${nodes.k8sm.master.id}]: |-
              kubectl apply -f ${baseUrl}/addons/ingress/${globals.ingress-dir}/api-ingress.yaml
          - setGlobals:
              default_api: or [Remote API Endpoint](${env.protocol}://${env.domain}/api/)

  install-components:
    - cmd[${nodes.k8sm.master.id}]: /usr/local/sbin/install-components.sh --base-url=$(echo '${baseUrl}' | base64 -w 0) --admin-account=true --metrics-server=true --dashboard=${settings.dashboard:none} --ingress-name=${globals.ingress-dir}

  install-helm-master:
    cmd[${nodes.k8sm.master.id}]: |-
      kubectl create serviceaccount --namespace kube-system tiller
      kubectl create clusterrolebinding tiller-cluster-rule --clusterrole=cluster-admin --serviceaccount=kube-system:tiller
      while true; do kubectl get serviceaccount tiller --namespace kube-system &> /dev/null && break; sleep 5; done
      /usr/local/sbin/helm-install.sh --master=true
      wait-deployment.sh tiller-deploy kube-system 1 720

  install-helm-slave:
    cmd[${this}]: screen -d -m /usr/bin/bash -c '/usr/local/sbin/helm-install.sh --master=false &>/var/log/kubernetes/k8s-helm-slave.log'

  generate-admin-token:
    - cmd[${nodes.k8sm.master.id}]: kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep fulladmin | awk '{print $1}')  | grep 'token:' | sed -e's/token:\| //g'
    - setGlobals:
        token: ${response.out}

  deploy:
    - if ('${settings.deploy}' == 'cc'):
        cmd[${nodes.k8sm.master.id}]: |-
          kubectl apply -f ${baseUrl}/addons/helloworld.yaml
          kubectl apply -f ${baseUrl}/addons/ingress/${globals.ingress-dir}/helloworld-ingress.yaml
    - if ('${settings.deploy}' == 'cmd'):
        cmd[${nodes.k8sm.master.id}]: |-
          ${settings.cmd}
          if [ '${settings.ingress-controller}' == "Nginx" ]; then kubectl delete ingress/open-liberty-traefik ingress/open-liberty-haproxy || true; fi
          if [ '${settings.ingress-controller}' == "HAProxy" ]; then kubectl delete ingress/open-liberty-traefik ingress/open-liberty-nginx || true; fi
          if [ '${settings.ingress-controller}' == "Traefik" ]; then kubectl delete ingress/open-liberty-haproxy ingress/open-liberty-nginx || true; fi
    - if ('${settings.deploy}' == 'yml'):
        cmd[${nodes.k8sm.master.id}]: kubectl apply -f ${settings.yml}

  helm-components:
    cmd[${nodes.k8sm.master.id}]: /usr/local/sbin/helm-components.sh --base-url=$(echo '${baseUrl}' | base64 -w 0) --nfs-provisioner=${settings.storage:false} --nfs-server=${nodes.storage.master.address:NULL} --metallb=true --problem-detector=true

  removeWorker:
    cmd[${nodes.k8sm.master.id}]: |-
      /usr/bin/kubectl drain ${this.workerHostname} --ignore-daemonsets --delete-local-data || exit 8;
      /usr/bin/kubectl delete node ${this.workerHostname} || exit 9;

  setup-remote-api:
  - log: '${this}'
  - cmd[${nodes.k8sm.master.id}]: |-
      action=$([ "${this}" == "true" ] && echo "apply" || echo "delete")
      kubectl $action -f ${baseUrl}/addons/ingress/${globals.ingress-dir}/api-ingress.yaml

  install-monitoring:
  - if (!${settings.storage:false}):
      return:
        type: warning
        message: Monitoring components require Storage installed!
  - cmd[${nodes.k8sm.master.id}]: kubectl get secret --namespace kubernetes-monitoring monitoring-grafana &>/dev/null && echo "true" || echo "false"
  - setGlobals:
      monitoring_installed: ${response.out}
  - if ('${globals.monitoring_installed}' == 'false'):
      - cmd[${nodes.k8sm.master.id}]: |-
          helm repo update
          helm install --name monitoring-prometheus --namespace kubernetes-monitoring stable/prometheus --set server.prefixURL=/prometheus --set server.baseURL=/prometheus
          wait-deployment.sh monitoring-prometheus-server kubernetes-monitoring 1 720
          helm fetch stable/grafana --untar
          for dash_name in "kubernetes-prometeus-dashboard" "kubernetes-rchakra3-dashboard" "kubernetes-vanniekerk-dashboard"; do
            wget "${baseUrl}/addons/monitoring/${dash_name}.json" -O "grafana/dashboards/${dash_name}.json"
          done
          helm install --name monitoring-grafana --namespace kubernetes-monitoring --set 'grafana\.ini'.server.root_url=${env.url}grafana -f ${baseUrl}/addons/monitoring/jelastic-values.yaml grafana/.
          wait-deployment.sh monitoring-grafana kubernetes-monitoring 1 720
          grafana_secret=$(kubectl get secret --namespace kubernetes-monitoring monitoring-grafana -o jsonpath='{.data.admin-password}' | base64 --decode ; echo)
          [ "${settings.ingress-controller}" == "HAProxy" ] && crypt_option="-1" || crypt_option="-apr1"
          kubectl create secret generic monitoring-prometheus --from-literal=auth="admin:$(openssl passwd ${crypt_option} ${grafana_secret})" --namespace=kubernetes-monitoring
          kubectl create -f ${baseUrl}/addons/monitoring/${globals.ingress-dir}/prometheus-ingress.yaml
          kubectl create -f ${baseUrl}/addons/monitoring/${globals.ingress-dir}/alert-ingress.yaml
          kubectl create -f ${baseUrl}/addons/monitoring/${globals.ingress-dir}/grafana-ingress.yaml
          for i in {1..10}; do
            sleep 10
            echo "Attempt ${i} of Grafana dashboard parameters setting"
            curl -X POST -f -d "user=admin&password=${grafana_secret}" -c grafana/grafana-jar.txt "http://${env.domain}/grafana/login" || contunue
            dash_id=$(curl -sb grafana/grafana-jar.txt 'http://${env.domain}/grafana/api/search?mode=tree&query=Jelastic' | grep -Po '"id":(\d+)' | awk -F ':' '{print $2}')
            [ "${dash_id}" = "" ] && continue
            curl -X POST -f -b grafana/grafana-jar.txt "http://${env.domain}/grafana/api/user/stars/dashboard/${dash_id}" || continue
            curl -X PUT -f -H 'Content-Type: application/json' -b grafana/grafana-jar.txt -d "{\"homeDashboardId\":${dash_id}}" "http://${env.domain}/grafana/api/org/preferences" && break || continue
          done
  - cmd[${nodes.k8sm.master.id}]: kubectl get secret --namespace kubernetes-monitoring monitoring-grafana -o jsonpath='{.data.admin-password}' | base64 --decode
  - setGlobals:
      grafana_secret: ${response.out}
      monitoring_success: |
          Enter [Prometheus dashboard](${env.url}prometheus/), [Prometheus AlertManager](${env.url}prometheus-alert/)
          and [Grafana dashboard](${env.url}grafana/), using login "admin" and password:

          ```${globals.grafana_secret}```
  - if ('${globals.monitoring_installed}' == 'true'):
      return:
        type: info
        message: ${globals.monitoring_success}
  - if (!${settings.monitoring:false}):
      message.email.send:
            to: "${user.email}"
            subject: Monitoring Tools Successfully Installed in ${env.name}
            body: |-
              Monitoring Tools installed in <b>${env.name}</b> Kubernetes Cluster: <br>
              Prometheus Dashboard - ${env.url}prometheus/<br>
              Prometheus AlertManager - ${env.url}prometheus-alert/ <br>
              Grafana Dashboard - ${env.url}grafana/ <br>
              Credentials - admin / ${globals.grafana_secret}
      return:
        type: info
        message: ${globals.monitoring_success}

  install-jaeger:
  - if (!${settings.storage:false}):
      return:
        type: warning
        message: Jaeger components require Storage installed!
  - cmd[${nodes.k8sm.master.id}]: kubectl get secret observability-jaeger-plain --namespace=observability &>/dev/null && echo "true" || echo "false"
  - setGlobals:
      jaeger_installed: ${response.out}
  - if ('${globals.jaeger_installed}' == 'false'):
      - cmd[${nodes.k8sm.master.id}]: |-
          kubectl create namespace observability
          kubectl create -f ${baseUrl}/addons/jaeger/jaegertracing.io_jaegers_crd.yaml
          kubectl create -f ${baseUrl}/addons/jaeger/service_account.yaml
          kubectl create -f ${baseUrl}/addons/jaeger/role.yaml
          kubectl create -f ${baseUrl}/addons/jaeger/role_binding.yaml
          kubectl create -f ${baseUrl}/addons/jaeger/operator.yaml
          [ "${settings.ingress-controller}" == "HAProxy" ] && crypt_option="-1" || crypt_option="-apr1"
          jaeger_secret=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1)
          kubectl create secret generic observability-jaeger-plain --from-literal=auth="${jaeger_secret}" --namespace=observability
          kubectl create secret generic observability-jaeger --from-literal=auth="admin:$(openssl passwd ${crypt_option} ${jaeger_secret})" --namespace=observability
          kubectl apply -f ${baseUrl}/addons/jaeger/jelastic-jaeger.yaml
          kubectl apply -f ${baseUrl}/addons/ingress/${globals.ingress-dir}/jaeger-ingress.yaml
          wait-deployment.sh jaeger-operator observability 1 720
          wait-deployment.sh jaeger observability 1 720
  - cmd[${nodes.k8sm.master.id}]: kubectl get secret --namespace=observability observability-jaeger-plain -o jsonpath='{.data.auth}' | base64 --decode
  - setGlobals:
      jaeger_secret: ${response.out}
      jaeger_success: |
          Enter [Jaeger dashboard](${env.url}jaeger/), using login "admin" and password:

          ```${globals.jaeger_secret}```
  - if ('${globals.jaeger_installed}' == 'true'):
      return:
        type: info
        message: ${globals.jaeger_success}
  - if (!${settings.jaeger:false}):
      message.email.send:
          to: "${user.email}"
          subject: Jaeger Tracing Tools Successfully Installed in ${env.name}
          body: |-
              Jaeger Tracing Tools installed in <b>${env.name}</b> Kubernetes Cluster: <br>
              Jaeger Dashboard - ${env.url}jaeger/ <br>
              Credentials - admin / ${globals.jaeger_secret}
      return:
        type: info
        message: ${globals.jaeger_success}

  check-health:
      cmd[${nodes.k8sm.master.id}]: /usr/local/sbin/check-install.sh -i=${settings.ingress-controller} -app=${settings.deploy} -m=${settings.monitoring:false} -r=${settings.api} -s=${settings.storage} -j=${settings.jaeger:false} -d=${env.domain}  &> /var/log/kubernetes/k8s-health-check.log || echo "*Warning! Some cluster components have not yet been initialized, and it may take some time for pods to start. If you encounter problems with your cluster, please check K8s logs in /var/log/kubernetes on master node and contact support.*"
      setGlobals:
         check_message: ${response.out}

addons:

  - id: conf-k8s-addon
    type: update
    baseUrl: https://raw.githubusercontent.com/jelastic-jps/kubernetes/v1.16.8
    name: Cluster Configuration
    description: Configure remote API access and install complementary tools
    logo: /images/k8s-config.png
    settings:
      fields:
        - type: displayfield
          caption: Useful info
          hideLabel: true
          markup: Access and manage the cluster remotely via API
        - type: checkbox
          name: api
          caption: Remote API access is enabled
        - type: string
          name: ingress-controller
          inputType: hidden
        - type: checkbox
          name: storage
          hidden: true

    buttons:
      - caption: Remote API
        settings: main
        action: addon-remote-api
        loadingText: Updating...
        confirmText: Are you sure?
        successText: Remote API Access was successfully updated!
      - caption: Monitoring
        action: install-monitoring
        confirmText: Monitoring tools will be installed if missing. Continue?
      - caption: Jaeger
        action: install-jaeger
        confirmText: Jaeger will be installed if missing. Continue?

    actions:
      addon-remote-api:
      - log: '${this.api}'
      - setup-remote-api: ${this.api}
      - if (${this.api:true}):
          - setGlobals:
              apiStatusMessage: enabled at ${env.url}api
      - else:
          - setGlobals:
              apiStatusMessage: disabled
      - message.email.send:
          to: "${user.email}"
          subject: Remote API Access Successfully Updated in ${env.name}
          body: Remote API has been ${globals.apiStatusMessage}


  - id: upgrade-k8s-addon
    type: update
    baseUrl: https://raw.githubusercontent.com/jelastic-jps/kubernetes/v1.16.8
    name: Cluster Upgrade
    description: Upgrade Kubernetes cluster to a newer version
    logo: /images/k8s-upgrade.png

    buttons:
      - caption: Start Cluster Upgrade
        action: addon-upgrade
        loadingText: Updating...
        confirmText: Do you want to upgrade Kubernetes Cluster?
        successText: Kubernetes Cluster has been successfully upgraded!

    actions:
      addon-upgrade:
      - forEach(node:env.nodes):
          if ('${@node.nodeGroup}' == 'cp' || '${@node.nodeGroup}' == 'k8sm'):
            if ('${nodes.k8sm.master.version}' != '${@node.version}'):
              return:
                type: warning
                message: Cluster components have different Kubernetes version! Please contact support before upgrade.
      - script: |
          var envName = "${env.envName}", nodeId = "${nodes.k8sm.master.id}";
          var resp = jelastic.env.control.GetNodeInfo(envName, session, nodeId);
          if (resp.result != 0) return resp;
          var version = resp.node.version;
          var image = resp.node.name;
          resp = jelastic.env.control.GetContainerNodeTags(envName, session, nodeId);
          if (resp.result != 0) return resp;
          var tags = resp.object;
          tags.sort();
          var upgrades = [];
          var check_version = version;
          var major_version = version.substr(0, version.lastIndexOf("."));
          for (var i = 0; i < tags.length; i++) {
            var major_tag = tags[i].substr(0, tags[i].lastIndexOf("."));
            if (major_tag > major_version) {
              check_version = tags[i];
              upgrades.push(check_version);
              major_version = major_tag;
            }
          }
          var last_version = tags.pop();
          if (last_version > check_version) upgrades.push(last_version);
          var message = "Current version " + version + " is the latest. No upgrades are available.";
          if (upgrades.length) {
            upgrades.sort();
            var next = upgrades.shift();
            var baseUrl = "${baseUrl}".split("/"); baseUrl.pop(); baseUrl = baseUrl.join("/");
            var url = baseUrl+"/"+next+"/addons/upgrade.jps"
            var huc = new java.net.URL(url).openConnection();
            huc.setRequestMethod("HEAD");
            var code = huc.getResponseCode();
            if (code == 200){
              return {result:0, onAfterReturn:{execUpgrade:{current:version, next:next, avail:upgrades.join(", "), jps: url}}};
            } else {
              message = "The next version is " + next + ". However, automated upgrade procedure is not available yet. Please check it later, or contact support team if upgrade is required urgently.";
              return {result:"info", message:message};
            }
          } else {
            return {result:"info", message:message};
          }

      execUpgrade:
        install: ${this.jps}
        envName: ${env.envName}
        settings:
            version: ${this.next}
            avail: ${this.avail}

  - id: gitlab-k8s-addon
    type: update
    baseUrl: https://raw.githubusercontent.com/jelastic-jps/kubernetes/v1.16.8
    name: GitLab Integration
    description: Add Kubernetes GitLab integrations
    logo: /images/k8s-gitlab.png
    settings:
      fields:
        - type: displayfield
          hideLabel: true
          markup: This addon provides Kubernetes and GitLab integration. Please select the Gitlab environment from the list, and specify Gitlab 'root' password.
        - type: displayfield
          hideLabel: true
        - type: envlist
          name: envlist
          valueField: shortdomain
          caption: GitLab environment

    buttons:
      - caption: Configure
        settings: gitlab
        action: addon-gitlab-config
        loadingText: Configuration...
        confirmText: Are you sure?
        successText: GitLab environment successfully configured!
      - caption: Remove Integration
        action: addon-gitlab-remove
        confirmText: Any existing Kubernetes and GitLab integration will be removed. Continue?
        successText: GitLab integration successfully removed!

    actions:
      addon-gitlab-config:
      - log: '${settings.envlist}'
      - cmd[${nodes.k8sm.master.id}]: kubectl get configmaps -n gitlab-managed-apps gitlab-configuration &>/dev/null && echo "true" || echo "false"
      - set:
          gitlab_installed: ${response.out}
      - if ('${this.gitlab_installed}' == 'true'):
          return:
            type: info
            message: This cluster already has GitLab integration!
      - env.control.GetEnvInfo:
          envName: ${settings.envlist}
      - set:
          gitlab_domain: ${response.env.domain}
      - env.control.ExecCmdByGroup [cp]:
          envName: ${settings.envlist}
          commandList:
            - command: echo ${ROOT_PASSWORD}
      - set:
          gitlab_pass: ${response.out}
      - env.control.ExecCmdByGroup [cp]:
          envName: ${settings.envlist}
          commandList:
            - command: echo ${HTTPS_PORT}
      - set:
          gitlab_port: ${response.out}
          gitlab_http_endpoint: "https://${this.gitlab_domain}:${this.gitlab_port}"
      - if ('${this.gitlab_pass}' == '' || '${this.gitlab_port}' == ''):
          return:
            type: warning
            message: Cannot determine GitLab credentials!
      - cmd[${nodes.k8sm.master.id}]: kubectl apply -f ${baseUrl}/addons/gitlab-service-account.yaml
      - cmd[${nodes.k8sm.master.id}]: kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep gitlab-admin | awk '{print $1}') | grep '^token:' | awk '{print $2}'
      - set:
          gitlab_token: ${response.out}
      - cmd[${nodes.k8sm.master.id}]: kubectl cluster-info | sed -r "s/\x1B\[([0-9]{1,3}((;[0-9]{1,3})*)?)?[m|K]//g" | grep 'Kubernetes master' | awk '/http/ {print $NF}'
      - set:
          gitlab_api_url: ${response.out}
      - cmd[${nodes.k8sm.master.id}]: kubectl get secret $(kubectl get secrets | grep default-token | cut -d " " -f 1) -o jsonpath="{['data']['ca\.crt']}" | base64 --decode
      - set:
          gitlab_ca_cert: ${response.out}
      - cmd[${nodes.k8sm.master.id}]: |-
          # Login
          page_content=$(curl -sk -c gitlab-jar.txt  '${this.gitlab_http_endpoint}/users/sign_in')
          csrf_token=$(echo ${page_content} | perl -ne 'print "$1\n" if /new_user.*?authenticity_token"[[:blank:]]value="(.+?)"/' | sed -n 1p)
          echo "Sign-in CSRF token: ${csrf_token}"
          [ -n "${csrf_token}" ] || exit 1
          curl -X POST -sk -b gitlab-jar.txt -c gitlab-jar.txt -f -d "user[login]=root&user[password]=${this.gitlab_pass}" --data-urlencode "authenticity_token=${csrf_token}" '${this.gitlab_http_endpoint}/users/sign_in'
      - cmd[${nodes.k8sm.master.id}]: |-
          # Settings
          page_content=$(curl -sk -b gitlab-jar.txt -c gitlab-jar.txt '${this.gitlab_http_endpoint}/admin/application_settings/network')
          csrf_token=$(echo ${page_content} | perl -ne 'print "$1\n" if /meta[[:blank:]]name="csrf-token"[[:blank:]]content="(.+?)"/' | sed -n 1p)
          echo "Application settings CSRF token: ${csrf_token}"
          [ -n "${csrf_token}" ] || exit 2
          curl -X POST -sk -b gitlab-jar.txt -c gitlab-jar.txt -f -d "_method=patch&application_setting[allow_local_requests_from_web_hooks_and_services]=1&application_setting[allow_local_requests_from_system_hooks]=1&application_setting[dns_rebinding_protection_enabled]=1" --data-urlencode "authenticity_token=${csrf_token}" '${this.gitlab_http_endpoint}/admin/application_settings/network' || exit 2
          curl -sk -b gitlab-jar.txt -c gitlab-jar.txt -f '${this.gitlab_http_endpoint}/admin/application_settings/network' &>/dev/null
      - cmd[${nodes.k8sm.master.id}]: |-
          # Cluster
          for i in {1..5}; do
            sleep 10
            echo "Attempt ${i} of GitLab Kubernetes cluster creation"
            page_content=$(curl -sk -b gitlab-jar.txt -c gitlab-jar.txt  '${this.gitlab_http_endpoint}/admin/clusters/new')
            csrf_token=$(echo ${page_content} | perl -ne 'print "$1\n" if /new_cluster.*?authenticity_token"[[:blank:]]value="(.+?)"/' | sed -n 1p)
            echo "Add cluster CSRF token: ${csrf_token}"
            [ -n "${csrf_token}" ] || continue
            page_content=$(curl -X POST -sk -b gitlab-jar.txt -c gitlab-jar.txt -d "cluster[name]=Kubernetes&cluster[platform_kubernetes_attributes][authorization_type]=rbac&cluster[managed]=1" --data-urlencode "cluster[platform_kubernetes_attributes][api_url]=${this.gitlab_api_url}" --data-urlencode "cluster[platform_kubernetes_attributes][ca_cert]=${this.gitlab_ca_cert}" --data-urlencode "cluster[platform_kubernetes_attributes][token]=${this.gitlab_token}" --data-urlencode "authenticity_token=${csrf_token}" '${this.gitlab_http_endpoint}/admin/clusters/create_user')
            cluster_url=$(echo ${page_content} | perl -ne 'print "$1\n" if /You[[:blank:]]are[[:blank:]]being[[:blank:]]\<a[[:blank:]]href="(.+?)"\>redirected/' | sed -n 1p)
            echo "Kubernetes GitLab cluster: ${cluster_url}"
            [ -n "${cluster_url}" ] && break || continue
          done
          echo "${page_content}"
          [ -n "${cluster_url}" ] || exit 4
          kubectl create ns gitlab-managed-apps
          kubectl create configmap gitlab-configuration --from-literal cluster_url="${cluster_url}" -n gitlab-managed-apps
      - cmd[${nodes.k8sm.master.id}]: kubectl get configmaps -n gitlab-managed-apps gitlab-configuration -o jsonpath='{.data.cluster_url}'
      - set:
          gitlab_cluster_url: ${response.out}
      - cmd[${nodes.k8sm.master.id}]: |-
          # Helm
          sleep 5
          page_content=$(curl -sk -b gitlab-jar.txt -c gitlab-jar.txt  "${this.gitlab_cluster_url}")
          csrf_token=$(echo ${page_content} | perl -ne 'print "$1\n" if /csrf-param.*?csrf-token"[[:blank:]]content="(.+?)"/' | sed -n 1p)
          echo "Helm CSRF token: ${csrf_token}"
          [ -n "${csrf_token}" ] || exit 5
          curl -X POST -sk -b gitlab-jar.txt -c gitlab-jar.txt -f -H "X-CSRF-Token: ${csrf_token}" "${this.gitlab_cluster_url}/applications/helm" || exit 5
          wait-deployment.sh tiller-deploy gitlab-managed-apps 1 720
      - cmd[${nodes.k8sm.master.id}]: |-
          # Ingress
          page_content=$(curl -sk -b gitlab-jar.txt -c gitlab-jar.txt "${this.gitlab_cluster_url}")
          csrf_token=$(echo ${page_content} | perl -ne 'print "$1\n" if /csrf-param.*?csrf-token"[[:blank:]]content="(.+?)"/' | sed -n 1p)
          echo "Ingress CSRF token: ${csrf_token}"
          [ -n "${csrf_token}" ] || exit 5
          curl -X POST -sk -b gitlab-jar.txt -c gitlab-jar.txt -f -H "X-CSRF-Token: ${csrf_token}" "${this.gitlab_cluster_url}/applications/ingress" || exit 5
          wait-deployment.sh ingress-nginx-ingress-controller gitlab-managed-apps 1 720
      - cmd[${nodes.k8sm.master.id}]: |-
          # Cert manager
          page_content=$(curl -sk -b gitlab-jar.txt -c gitlab-jar.txt "${this.gitlab_cluster_url}")
          csrf_token=$(echo ${page_content} | perl -ne 'print "$1\n" if /csrf-param.*?csrf-token"[[:blank:]]content="(.+?)"/' | sed -n 1p)
          echo "Cert-manager CSRF token: ${csrf_token}"
          [ -n "${csrf_token}" ] || exit 5
          curl -X POST -sk -b gitlab-jar.txt -c gitlab-jar.txt -f -H "Content-Type: application/json" -H "X-CSRF-Token: ${csrf_token}" -d '{"email":"${user.email}"}' "${this.gitlab_cluster_url}/applications/cert_manager" || exit 5
          wait-deployment.sh certmanager-webhook gitlab-managed-apps 1 720
      - cmd[${nodes.k8sm.master.id}]: |-
          # Runner
          page_content=$(curl -sk -b gitlab-jar.txt -c gitlab-jar.txt "${this.gitlab_cluster_url}")
          csrf_token=$(echo ${page_content} | perl -ne 'print "$1\n" if /csrf-param.*?csrf-token"[[:blank:]]content="(.+?)"/' | sed -n 1p)
          echo "Runner CSRF token: ${csrf_token}"
          [ -n "${csrf_token}" ] || exit 5
          curl -X POST -sk -b gitlab-jar.txt -c gitlab-jar.txt -f -H "X-CSRF-Token: ${csrf_token}" "${this.gitlab_cluster_url}/applications/runner" || exit 5
          wait-deployment.sh runner-gitlab-runner gitlab-managed-apps 1 720

      addon-gitlab-remove:
      - cmd[${nodes.k8sm.master.id}]: kubectl get ns gitlab-managed-apps &>/dev/null && echo "true" || echo "false"
      - setGlobals:
          gitlab_installed: ${response.out}
      - if ('${globals.gitlab_installed}' == 'false'):
          return:
            type: info
            message: This cluster has no active GitLab integration!
      - cmd[${nodes.k8sm.master.id}]: |-
          kubectl delete ns gitlab-managed-apps
          kubectl delete -f ${baseUrl}/addons/gitlab-service-account.yaml

  - id: certman-k8s-addon
    type: update
    requiredFeatures: extip
    baseUrl: https://raw.githubusercontent.com/jelastic-jps/kubernetes/v1.16.8
    name: Certificate Manager
    description: Kubernetes SSL Certificate Manager
    logo: /images/k8s-cert.png
    settings:
      fields:
        - type: displayfield
          hideLabel: true
          markup: This addon provides Kubernetes Certificate Manager installation. Please specify external DNS name to assign the certificate with.
        - type: displayfield
          hideLabel: true
        - type: string
          caption: External domain
          name: certificate_domain
    buttons:
      - caption: Install Certificate Manager
        settings: certman
        action: addon-certman-config
        loadingText: Installing...
        confirmText: Do you want to install Certificate Manager?
        successText: Certficate manager has been successfully installed!

    actions:
      addon-certman-config:
      - cmd[${nodes.k8sm.master.id}]: kubectl -n cert-manager get deployment cert-manager &>/dev/null && echo "true" || echo "false"
      - if ('${response.out}' == 'true'):
          return:
            type: warning
            message: Kubernetes Certificate Manager is already configured! Please use Kubernetes Cluster settings!
      - cmd[${nodes.k8sm.master.id}]: |-
          certmanager_version=0.13.0
          kubectl create namespace cert-manager
          kubectl apply --validate=false -f https://raw.githubusercontent.com/jetstack/cert-manager/v${certmanager_version}/deploy/manifests/00-crds.yaml
          helm repo add jetstack https://charts.jetstack.io
          helm repo update
          helm install --name cert-manager --namespace cert-manager --version v${certmanager_version} jetstack/cert-manager
          wait-deployment.sh cert-manager cert-manager 1 720
          helm install stable/nginx-ingress --name cert-manager-nginx --namespace cert-manager --set controller.ingressClass=nginx-cert
          wait-deployment.sh cert-manager-nginx-nginx-ingress-controller cert-manager 1 720
          for issuer_name in "le-production-issuer" "le-staging-issuer"; do
            wget "${baseUrl}/addons/cert-manager/${issuer_name}.yaml" -O "/tmp/${issuer_name}.yaml"
            sed -i 's/user@example\.com/${user.email}/g' "/tmp/${issuer_name}.yaml"
            kubectl create -f "/tmp/${issuer_name}.yaml"
          done
          wget "${baseUrl}/addons/cert-manager/helloworld-ingress.yaml" -O /tmp/helloworld-ingress.yaml
          sed -i 's/example\.com/${settings.certificate_domain}/g' /tmp/helloworld-ingress.yaml
          kubectl apply -f /tmp/helloworld-ingress.yaml

success: |
  ${globals.default_success:}
  ${globals.monitoring_success:}
  ${globals.jaeger_success:}
  ${globals.check_message:}
